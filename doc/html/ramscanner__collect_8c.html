<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ramscanner: ramscanner_collect.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ramscanner</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>ramscanner_collect.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="ramscanner__collect_8h_source.html">ramscanner_collect.h</a>&quot;</code><br/>
</div>
<p><a href="ramscanner__collect_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#acdce25f682f7cc424909fbabf5f005db">parse_smaps_file</a> (FILE *file, <a class="el" href="structsizestats.html">sizestats</a> *stats)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#afb500da45a8a85f07f223decbde00f22">countgss</a> (void *key, void *value, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#a7b7e7a2bbf9bb7ac7ffea207dd67f048">countsss</a> (void *key, void *value, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#a51f3b3a2fe684b082ef2d5190a125df7">lookup_smaps</a> (pid_t PID, <a class="el" href="structsizestats.html">sizestats</a> *stats)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#afce862818e4b085e82ab08a9e3d75cfd">store_flags_in_page</a> (uint64_t bitfield, <a class="el" href="structpagedetaildata.html">pagedetaildata</a> *currentdpage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#ab0fccb96a9d60f7da5326e4616541227">use_pfn</a> (uint64_t pfn, <a class="el" href="structoptions.html">options</a> *opt, FILE *filepageflags, FILE *filepagecount, <a class="el" href="structpagedetaildata.html">pagedetaildata</a> *currentdpage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#aa002283ea1ba949cdd204719353732e1">parse_bitfield</a> (uint64_t bitfield, <a class="el" href="structoptions.html">options</a> *opt, FILE *filepageflags, FILE *filepagecount, <a class="el" href="structpagedetaildata.html">pagedetaildata</a> *currentdpage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#af9ea1162d4f7a57283dcdcf35be2bccd">are_pages_identical_and_adjacent</a> (<a class="el" href="structpagedetaildata.html">pagedetaildata</a> *prev, <a class="el" href="structpagedetaildata.html">pagedetaildata</a> *curr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#a50b3f0e53f509ce2e69f18fa1e61358c">lookup_pagemap_with_addresses</a> (uint32_t addressfrom, uint32_t addressto, <a class="el" href="structoptions.html">options</a> *opt, FILE *filepageflags, FILE *filepagecount, FILE *filepagemap, uint16_t vmaindex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvmastats.html">vmastats</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#a712555ae6bff502a411333314d8b2b95">make_another_vmst_in_opt</a> (<a class="el" href="structoptions.html">options</a> *opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#abffda3486ef70acf1cd5492c3eaf585f">lookup_maps_with_PID</a> (pid_t pid, <a class="el" href="structoptions.html">options</a> *opt, FILE *filepageflags, FILE *filepagecount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramscanner__collect_8c.html#ab5dc8716f53334cd9895c210ab4c93fa">inspect_processes</a> (<a class="el" href="structoptions.html">options</a> *opt)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af9ea1162d4f7a57283dcdcf35be2bccd"></a><!-- doxytag: member="ramscanner_collect.c::are_pages_identical_and_adjacent" ref="af9ea1162d4f7a57283dcdcf35be2bccd" args="(pagedetaildata *prev, pagedetaildata *curr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int are_pages_identical_and_adjacent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpagedetaildata.html">pagedetaildata</a> *&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpagedetaildata.html">pagedetaildata</a> *&#160;</td>
          <td class="paramname"><em>curr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks whether two page detail data structs are identical enough to merge together. Checks whether the two page detail data structs are adjacent, assuming that prev is always before curr. It ignores the PFN from identity checks because checking PFN would check if it is the same page, rather than one with the exact same flags. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00295">295</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8h_source.html#l00129">pagedetaildata::addrend</a>, <a class="el" href="ramscanner__common_8h_source.html#l00126">pagedetaildata::addrstart</a>, <a class="el" href="ramscanner__common_8h_source.html#l00157">pagedetaildata::anonymous</a>, <a class="el" href="ramscanner__common_8h_source.html#l00154">pagedetaildata::dirty</a>, <a class="el" href="ramscanner__common_8h_source.html#l00162">pagedetaildata::ksm</a>, <a class="el" href="ramscanner__common_8h_source.html#l00150">pagedetaildata::locked</a>, <a class="el" href="ramscanner__common_8h_source.html#l00138">pagedetaildata::pageshift</a>, <a class="el" href="ramscanner__common_8h_source.html#l00135">pagedetaildata::present</a>, <a class="el" href="ramscanner__common_8h_source.html#l00151">pagedetaildata::referenced</a>, <a class="el" href="ramscanner__common_8h_source.html#l00141">pagedetaildata::swap</a>, <a class="el" href="ramscanner__common_8h_source.html#l00161">pagedetaildata::swapbacked</a>, <a class="el" href="ramscanner__common_8h_source.html#l00158">pagedetaildata::swapcache</a>, <a class="el" href="ramscanner__common_8h_source.html#l00147">pagedetaildata::timesmapped</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00132">pagedetaildata::vmaindex</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00325">lookup_pagemap_with_addresses()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordflow">if</span> (prev == NULL)                           <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a780c3a4bd914a2da49aafb7c99cc216a">addrend</a>     != curr-&gt;<a class="code" href="structpagedetaildata.html#a75c19d5792d61926ccc91eeec4c24026">addrstart</a>)   <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#af3eee3b51b1146030f02c43ad62e6d11">vmaindex</a>    != curr-&gt;<a class="code" href="structpagedetaildata.html#af3eee3b51b1146030f02c43ad62e6d11">vmaindex</a>)    <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a036707143fb5b570d5a652f406140c0f">present</a>     != curr-&gt;<a class="code" href="structpagedetaildata.html#a036707143fb5b570d5a652f406140c0f">present</a>)     <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a22b602c3181c247f9763370ecffd707c">pageshift</a>   != curr-&gt;<a class="code" href="structpagedetaildata.html#a22b602c3181c247f9763370ecffd707c">pageshift</a>)   <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#abf014a39240094609ea641ae130ca2f3">swap</a>        != curr-&gt;<a class="code" href="structpagedetaildata.html#abf014a39240094609ea641ae130ca2f3">swap</a>)        <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a2301773722c04effa8e6a282a5a7242b">timesmapped</a> != curr-&gt;<a class="code" href="structpagedetaildata.html#a2301773722c04effa8e6a282a5a7242b">timesmapped</a>) <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#ab79ca79b587b4646615ae409c636aa90">locked</a>      != curr-&gt;<a class="code" href="structpagedetaildata.html#ab79ca79b587b4646615ae409c636aa90">locked</a>)      <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a1aedae3537012074ad0e3ab7d093271e">referenced</a>  != curr-&gt;<a class="code" href="structpagedetaildata.html#a1aedae3537012074ad0e3ab7d093271e">referenced</a>)  <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a194a712df4b4857b536603185f1630d2">dirty</a>       != curr-&gt;<a class="code" href="structpagedetaildata.html#a194a712df4b4857b536603185f1630d2">dirty</a>)       <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a42cda287fd0972398739701653dde809">anonymous</a>   != curr-&gt;<a class="code" href="structpagedetaildata.html#a42cda287fd0972398739701653dde809">anonymous</a>)   <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#aa066a464cadc63d63d64cc9372ea1658">swapcache</a>   != curr-&gt;<a class="code" href="structpagedetaildata.html#aa066a464cadc63d63d64cc9372ea1658">swapcache</a>)   <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a3fe2eefda8955b201eaf9ddf9077243f">swapbacked</a>  != curr-&gt;<a class="code" href="structpagedetaildata.html#a3fe2eefda8955b201eaf9ddf9077243f">swapbacked</a>)  <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (prev-&gt;<a class="code" href="structpagedetaildata.html#a94233c04763e267acacd5116a443b2d6">ksm</a>         != curr-&gt;<a class="code" href="structpagedetaildata.html#a94233c04763e267acacd5116a443b2d6">ksm</a>)         <span class="keywordflow">return</span> 0;
        <span class="keywordflow">return</span> 1;
        
}
</pre></div>
</div>
</div>
<a class="anchor" id="afb500da45a8a85f07f223decbde00f22"></a><!-- doxytag: member="ramscanner_collect.c::countgss" ref="afb500da45a8a85f07f223decbde00f22" args="(void *key, void *value, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void countgss </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function called in a g_hash_table_foreach(). If the page is mapped only by the primary and secondary processes, it increments the Group Set Size by the size of the page in kB. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00084">84</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8h_source.html#l00037">sizestats::gss</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00044">KBSIZE</a>, <a class="el" href="ramscanner__common_8h_source.html#l00113">pagesummarydata::memmapped</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00117">pagesummarydata::procmapped</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00518">inspect_processes()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">size_t</span> pagesize = getpagesize();
        <a class="code" href="structpagesummarydata.html">pagesummarydata</a> *page = value;
        <a class="code" href="structsizestats.html">sizestats</a> *stats = data;
        <span class="keywordflow">if</span> (page-&gt;<a class="code" href="structpagesummarydata.html#a1a2f3d1078136de046abbde0c345f797">memmapped</a> == page-&gt;<a class="code" href="structpagesummarydata.html#a5d3c0039dc383c052e40193e791bf591">procmapped</a>)
                stats-&gt;<a class="code" href="structsizestats.html#a3364cb7c6fd00d0dc379bffc43452fcc">gss</a> += pagesize/<a class="code" href="ramscanner__collect_8h.html#aa44bab413ffdffd5924758b448641ea3">KBSIZE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7b7e7a2bbf9bb7ac7ffea207dd67f048"></a><!-- doxytag: member="ramscanner_collect.c::countsss" ref="a7b7e7a2bbf9bb7ac7ffea207dd67f048" args="(void *key, void *value, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void countsss </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function called in a g_hash_table_foreach(). If the page is mapped only by the primary process, it increments the Self Set Size by the size of the page in kB. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00099">99</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__collect_8h_source.html#l00044">KBSIZE</a>, <a class="el" href="ramscanner__common_8h_source.html#l00113">pagesummarydata::memmapped</a>, <a class="el" href="ramscanner__common_8h_source.html#l00117">pagesummarydata::procmapped</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00033">sizestats::sss</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00518">inspect_processes()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">size_t</span> pagesize = getpagesize();
        <a class="code" href="structpagesummarydata.html">pagesummarydata</a> *page = value;
        <a class="code" href="structsizestats.html">sizestats</a> *stats = data;
        <span class="keywordflow">if</span> (page-&gt;<a class="code" href="structpagesummarydata.html#a1a2f3d1078136de046abbde0c345f797">memmapped</a> == page-&gt;<a class="code" href="structpagesummarydata.html#a5d3c0039dc383c052e40193e791bf591">procmapped</a>)
                stats-&gt;<a class="code" href="structsizestats.html#a8a30f664c67729abaf194e57d3c2a0ab">sss</a> += pagesize/<a class="code" href="ramscanner__collect_8h.html#aa44bab413ffdffd5924758b448641ea3">KBSIZE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab5dc8716f53334cd9895c210ab4c93fa"></a><!-- doxytag: member="ramscanner_collect.c::inspect_processes" ref="ab5dc8716f53334cd9895c210ab4c93fa" args="(options *opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inspect_processes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoptions.html">options</a> *&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates all the information for ramscanner, storing it in the GHashTables opt-&gt;summarypages and opt-&gt;detailpages, the vmastats array opt-&gt;vmas, and the sizestats struct opt-&gt;summarystats, using opt-&gt;summary, opt-&gt;detail and opt-&gt;compactdetail to identify how much work it needs to do. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00518">518</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8c_source.html#l00039">cleanup_and_exit()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00079">options::compactdetail</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00084">countgss()</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00099">countsss()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00076">options::detail</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00034">KPAGECOUNT_FILENAME</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00033">KPAGEFLAGS_FILENAME</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00432">lookup_maps_with_PID()</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00113">lookup_smaps()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00089">options::pidcount</a>, <a class="el" href="ramscanner__common_8h_source.html#l00085">options::pids</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00032">PROC_PATH</a>, <a class="el" href="ramscanner__common_8h_source.html#l00073">options::summary</a>, <a class="el" href="ramscanner__common_8h_source.html#l00090">options::summarypages</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00098">options::summarystats</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__main_8c_source.html#l00016">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">char</span> pathbuf[PATH_MAX]; <span class="comment">/* Buffer for storing path to open files*/</span>
        FILE *filepageflags;<span class="comment">/* file descriptor for /proc/kpageflags */</span>
        FILE *filepagecount;<span class="comment">/* ditto for /proc/kpagecount */</span>
        <span class="keywordtype">int</span> i;
        <span class="keywordtype">int</span> ret;

        <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a> || opt-&gt;<a class="code" href="structoptions.html#aef87d29ef02ab135ff237eb2c7b9f9a7">compactdetail</a>) {
                sprintf(pathbuf, <span class="stringliteral">&quot;%s/%s&quot;</span>, <a class="code" href="ramscanner__literals_8h.html#a149096b34cfc7cb6a5fefebcd953f4d5">PROC_PATH</a>, <a class="code" href="ramscanner__literals_8h.html#ac7472b1a88b7d562157ab35cf524c8bb">KPAGEFLAGS_FILENAME</a>);
                errno = 0;
                filepageflags = fopen(pathbuf, <span class="stringliteral">&quot;r&quot;</span>);
                <span class="keywordflow">if</span> (filepageflags == NULL) {
                        perror(<span class="stringliteral">&quot;Error occurred opening kpageflags&quot;</span>);
                        <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
                }
        }

        sprintf(pathbuf, <span class="stringliteral">&quot;%s/%s&quot;</span>, <a class="code" href="ramscanner__literals_8h.html#a149096b34cfc7cb6a5fefebcd953f4d5">PROC_PATH</a>, <a class="code" href="ramscanner__literals_8h.html#a6dabe4fcade36fb0f22fde58e3289a1f">KPAGECOUNT_FILENAME</a>);
        errno = 0;
        filepagecount = fopen(pathbuf, <span class="stringliteral">&quot;r&quot;</span>);
        <span class="keywordflow">if</span> (filepagecount == NULL) {
                perror(<span class="stringliteral">&quot;Error occurred opening kpagecount&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }

        <a class="code" href="ramscanner__collect_8c.html#abffda3486ef70acf1cd5492c3eaf585f">lookup_maps_with_PID</a>(opt-&gt;<a class="code" href="structoptions.html#a3aa35d527ad06e54e301bae6f1ffe5b2">pids</a>[0], opt,
                             filepageflags, filepagecount);

        <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#aa46b832c2b73ca872baee120bb4bc755">summary</a>) {
                <a class="code" href="structoptions.html">options</a> opt2 = *opt;
                g_hash_table_foreach(opt-&gt;<a class="code" href="structoptions.html#a3f12bfa404a3402c0506d8dc52da4c4c">summarypages</a>, <a class="code" href="ramscanner__collect_8c.html#a7b7e7a2bbf9bb7ac7ffea207dd67f048">countsss</a>,
                                     &amp;(opt-&gt;<a class="code" href="structoptions.html#a40fbf684316fd9e0819ab090506d3c19">summarystats</a>));

                opt2.<a class="code" href="structoptions.html#aa46b832c2b73ca872baee120bb4bc755">summary</a> = 0;
                opt2.<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a> = 0;
                opt2.<a class="code" href="structoptions.html#aef87d29ef02ab135ff237eb2c7b9f9a7">compactdetail</a> = 0;
                <span class="keywordflow">for</span> (i = 1; i &lt; opt-&gt;<a class="code" href="structoptions.html#af48db6b2a8fd988837b4b2e9d4d31a61">pidcount</a>; i++) {
                        <a class="code" href="ramscanner__collect_8c.html#abffda3486ef70acf1cd5492c3eaf585f">lookup_maps_with_PID</a>(opt-&gt;<a class="code" href="structoptions.html#a3aa35d527ad06e54e301bae6f1ffe5b2">pids</a>[i], &amp;opt2,
                                             filepageflags,
                                             filepagecount);            
                }

                g_hash_table_foreach(opt-&gt;<a class="code" href="structoptions.html#a3f12bfa404a3402c0506d8dc52da4c4c">summarypages</a>, <a class="code" href="ramscanner__collect_8c.html#afb500da45a8a85f07f223decbde00f22">countgss</a>,
                                     &amp;(opt-&gt;<a class="code" href="structoptions.html#a40fbf684316fd9e0819ab090506d3c19">summarystats</a>));
                <a class="code" href="ramscanner__collect_8c.html#a51f3b3a2fe684b082ef2d5190a125df7">lookup_smaps</a>(opt-&gt;<a class="code" href="structoptions.html#a3aa35d527ad06e54e301bae6f1ffe5b2">pids</a>[0], &amp;(opt-&gt;<a class="code" href="structoptions.html#a40fbf684316fd9e0819ab090506d3c19">summarystats</a>));

        }
        <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a> || opt-&gt;<a class="code" href="structoptions.html#aef87d29ef02ab135ff237eb2c7b9f9a7">compactdetail</a>) {
                errno = 0;
                ret = fclose(filepageflags);
                <span class="keywordflow">if</span> (ret == EOF) {
                        perror(<span class="stringliteral">&quot;Error closing kpageflags file&quot;</span>);
                        errno = 0;
                }
        }
        errno = 0;
        ret = fclose(filepagecount);
        <span class="keywordflow">if</span> (ret == EOF) {
                perror(<span class="stringliteral">&quot;Error closing kpagecount file&quot;</span>);
                errno = 0;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="abffda3486ef70acf1cd5492c3eaf585f"></a><!-- doxytag: member="ramscanner_collect.c::lookup_maps_with_PID" ref="abffda3486ef70acf1cd5492c3eaf585f" args="(pid_t pid, options *opt, FILE *filepageflags, FILE *filepagecount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lookup_maps_with_PID </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoptions.html">options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepageflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepagecount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Uses the PID to access the appropriate /proc/PID/maps file, which contains permissions and path information about each Virtual Memory Area (VMA), and the region that memory addresses exist for. Assumes constant-sized pages to pass the range of indexes to be accessed in /proc/PID/pagemap. Calls the function <a class="el" href="ramscanner__collect_8c.html#a50b3f0e53f509ce2e69f18fa1e61358c">lookup_pagemap_with_addresses()</a> with the range of indexes to interrogate each listing in pagemap </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00432">432</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8c_source.html#l00039">cleanup_and_exit()</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00325">lookup_pagemap_with_addresses()</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00406">make_another_vmst_in_opt()</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00035">MAPS_FILENAME</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00037">PAGEMAP_FILENAME</a>, <a class="el" href="ramscanner__common_8h_source.html#l00063">vmastats::path</a>, <a class="el" href="ramscanner__common_8h_source.html#l00060">vmastats::permissions</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00032">PROC_PATH</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00104">options::vmacount</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00518">inspect_processes()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">char</span> pathbuf[PATH_MAX];
        <span class="keywordtype">char</span> buffer[BUFSIZ]; <span class="comment">/* Buffer for storing lines read from file*/</span>
        FILE *filemaps;
        FILE *filepagemap;
        <span class="keywordtype">int</span> ret;
        <span class="keywordtype">char</span> *pos = NULL;

        sprintf(pathbuf, <span class="stringliteral">&quot;%s/%u/%s&quot;</span>, <a class="code" href="ramscanner__literals_8h.html#a149096b34cfc7cb6a5fefebcd953f4d5">PROC_PATH</a>, pid, <a class="code" href="ramscanner__literals_8h.html#a208031be13c7a171d84335a87ae48a99">MAPS_FILENAME</a>);
        errno = 0;
        filemaps = fopen(pathbuf, <span class="stringliteral">&quot;r&quot;</span>);
        <span class="keywordflow">if</span> (filemaps == NULL) {
                perror(<span class="stringliteral">&quot;Error opening maps file&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }

        sprintf(pathbuf, <span class="stringliteral">&quot;%s/%u/%s&quot;</span>, <a class="code" href="ramscanner__literals_8h.html#a149096b34cfc7cb6a5fefebcd953f4d5">PROC_PATH</a>, pid, <a class="code" href="ramscanner__literals_8h.html#a39185a5d660b39b08c3c4debd4b73b97">PAGEMAP_FILENAME</a>);
        errno = 0;
        filepagemap = fopen(pathbuf, <span class="stringliteral">&quot;r&quot;</span>);
        <span class="keywordflow">if</span> (filepagemap == NULL) {
                perror(<span class="stringliteral">&quot;Error opening pagemap file&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }

        <span class="keywordflow">while</span> (fgets(buffer, BUFSIZ, filemaps) != NULL) {
                <a class="code" href="structvmastats.html">vmastats</a> *vmst = <a class="code" href="ramscanner__collect_8c.html#a712555ae6bff502a411333314d8b2b95">make_another_vmst_in_opt</a>(opt);
                uint16_t vmaindex = opt-&gt;<a class="code" href="structoptions.html#a70a839c12fbd2059a75cda3b8af76085">vmacount</a> - 1;
                uint32_t addrstart;
                uint32_t addrend;

                errno = 0;
                ret = sscanf(buffer, <span class="stringliteral">&quot;%x-%x %4s&quot;</span>, &amp;addrstart, &amp;addrend,
                             vmst-&gt;<a class="code" href="structvmastats.html#aacf49798007b530efd7a49e051d20c54">permissions</a>);
                <span class="keywordflow">if</span> (ret == EOF &amp;&amp; errno != 0) {
                        perror(<span class="stringliteral">&quot;Error parsing addresses from a line of maps&quot;</span>
                               <span class="stringliteral">&quot; file&quot;</span>);
                        <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
                }

                <span class="keywordflow">if</span> (ret &lt; 3){
                        fprintf(stderr, <span class="stringliteral">&quot;Error: Unexpected format of line in&quot;</span>
                                        <span class="stringliteral">&quot;maps.\n&quot;</span>);
                        <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
                }

                <span class="keywordflow">if</span> ((pos = strchr(buffer, <span class="charliteral">&#39;/&#39;</span>)) != NULL) {
                        <span class="keywordtype">char</span> *newlinepos;
                        strcpy(vmst-&gt;<a class="code" href="structvmastats.html#ab3204e1620ba49d665203a91c6af5fd8">path</a>, pos);
                        newlinepos = strrchr(vmst-&gt;<a class="code" href="structvmastats.html#ab3204e1620ba49d665203a91c6af5fd8">path</a>, <span class="charliteral">&#39;\n&#39;</span>);
                        *newlinepos = <span class="charliteral">&#39;\0&#39;</span>;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((pos = strchr(buffer, <span class="charliteral">&#39;[&#39;</span>)) != NULL) {
                        <span class="keywordtype">char</span> *newlinepos;
                        strcpy(vmst-&gt;<a class="code" href="structvmastats.html#ab3204e1620ba49d665203a91c6af5fd8">path</a>, pos);
                        newlinepos = strrchr(vmst-&gt;<a class="code" href="structvmastats.html#ab3204e1620ba49d665203a91c6af5fd8">path</a>, <span class="charliteral">&#39;\n&#39;</span>);
                        *newlinepos = <span class="charliteral">&#39;\0&#39;</span>;
                }

                <a class="code" href="ramscanner__collect_8c.html#a50b3f0e53f509ce2e69f18fa1e61358c">lookup_pagemap_with_addresses</a>(addrstart, 
                                              addrend, opt,
                                              filepageflags, filepagecount,
                                              filepagemap, vmaindex);
        }

        errno = 0;
        ret = fclose(filemaps);
        <span class="keywordflow">if</span> (ret == EOF) {
                perror(<span class="stringliteral">&quot;Error closing maps file&quot;</span>);
                errno = 0;
        }
        errno = 0;
        ret = fclose(filepagemap);
        <span class="keywordflow">if</span> (ret == EOF) {
                perror(<span class="stringliteral">&quot;Error closing pagemap file&quot;</span>);
                errno = 0;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a50b3f0e53f509ce2e69f18fa1e61358c"></a><!-- doxytag: member="ramscanner_collect.c::lookup_pagemap_with_addresses" ref="a50b3f0e53f509ce2e69f18fa1e61358c" args="(uint32_t addressfrom, uint32_t addressto, options *opt, FILE *filepageflags, FILE *filepagecount, FILE *filepagemap, uint16_t vmaindex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lookup_pagemap_with_addresses </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addressfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addressto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoptions.html">options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepageflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepagecount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepagemap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vmaindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up every entry in /proc/PID/pagemap over the range addressfrom to addressto, creating a pagedetaildata struct and filling it by using <a class="el" href="ramscanner__collect_8c.html#aa002283ea1ba949cdd204719353732e1">parse_bitfield()</a>. If that page is both identical and adjacent to the previous page made, then it merges the two pages together by changing the address of the end of the previous page to the end address of the new page, then discarding the new page. If they are not adjacent and identical, it stores the new page in the GHashTable opt-&gt;detailpages. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00325">325</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8h_source.html#l00129">pagedetaildata::addrend</a>, <a class="el" href="ramscanner__common_8h_source.html#l00126">pagedetaildata::addrstart</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00295">are_pages_identical_and_adjacent()</a>, <a class="el" href="ramscanner__common_8c_source.html#l00039">cleanup_and_exit()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00094">options::detailpages</a>, <a class="el" href="ramscanner__common_8c_source.html#l00016">newkey()</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00254">parse_bitfield()</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00132">pagedetaildata::vmaindex</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00432">lookup_maps_with_PID()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">size_t</span> entrysize = <span class="keyword">sizeof</span>(uint64_t);
        <span class="keywordtype">size_t</span> pagesize = getpagesize();
        <a class="code" href="structpagedetaildata.html">pagedetaildata</a> *previousdpage = NULL;
        <a class="code" href="structpagedetaildata.html">pagedetaildata</a> *currentdpage;
        errno = 0;
        currentdpage = calloc(1, <span class="keyword">sizeof</span>(*currentdpage));
        <span class="keywordflow">if</span> (currentdpage == NULL) {
                perror(<span class="stringliteral">&quot;Error occurred allocating memory for detail page&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }

        uint32_t entryfrom = addressfrom / pagesize;
        uint32_t entryto = addressto / pagesize;
        <span class="comment">/* Multiplying and dividing done in separate steps because multiplying</span>
<span class="comment">         * address by entrysize often causes an overflow. </span>
<span class="comment">         */</span>
        entryfrom *= entrysize;
        entryto *= entrysize;

        uint32_t i;
        
        <span class="keywordflow">for</span> (i = entryfrom; i &lt; entryto; i += entrysize) {
                <span class="keywordtype">int</span> inum = i / entrysize;
                <span class="keywordtype">int</span> ret;
                uint64_t bitfield;
                uint32_t o;

                errno = 0;
                o = fseek(filepagemap, i, SEEK_SET);
                <span class="keywordflow">if</span> (o == -1) {
                        perror(<span class="stringliteral">&quot;Error seeking in pagemap&quot;</span>);
                        <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
                }
                errno = 0;
                ret = fread(&amp;bitfield, <span class="keyword">sizeof</span>(bitfield), 1, filepagemap);
                <span class="keywordflow">if</span> (ret != 1) {
                        perror(<span class="stringliteral">&quot;Error reading pagemap&quot;</span>);
                        <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
                }

                currentdpage-&gt;<a class="code" href="structpagedetaildata.html#af3eee3b51b1146030f02c43ad62e6d11">vmaindex</a> = vmaindex;
                currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a75c19d5792d61926ccc91eeec4c24026">addrstart</a> = inum * pagesize;
                currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a780c3a4bd914a2da49aafb7c99cc216a">addrend</a> = (inum + 1) * pagesize;

                <a class="code" href="ramscanner__collect_8c.html#aa002283ea1ba949cdd204719353732e1">parse_bitfield</a>(bitfield, opt, 
                               filepageflags, filepagecount, currentdpage);

                <span class="keywordflow">if</span> (<a class="code" href="ramscanner__collect_8c.html#af9ea1162d4f7a57283dcdcf35be2bccd">are_pages_identical_and_adjacent</a>(previousdpage,
                                                     currentdpage)) {
                        previousdpage-&gt;<a class="code" href="structpagedetaildata.html#a780c3a4bd914a2da49aafb7c99cc216a">addrend</a> = currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a780c3a4bd914a2da49aafb7c99cc216a">addrend</a>;
                        memset(currentdpage, 0, <span class="keyword">sizeof</span>(*currentdpage));
                } <span class="keywordflow">else</span> {
                        g_hash_table_insert(opt-&gt;<a class="code" href="structoptions.html#a3633157dccdfa6c34ba42b290f7cab34">detailpages</a>, 
                                            <a class="code" href="ramscanner__common_8c.html#af9b4ea763f4ee48879a5efc735d079c5">newkey</a>(currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a75c19d5792d61926ccc91eeec4c24026">addrstart</a>), 
                                            currentdpage);
                        previousdpage = currentdpage;
                        errno = 0;
                        currentdpage = calloc(1, <span class="keyword">sizeof</span>(*currentdpage));
                        <span class="keywordflow">if</span> (currentdpage == NULL) {
                                perror(<span class="stringliteral">&quot;Error occurred allocating memory for&quot;</span>
                                       <span class="stringliteral">&quot; detail page&quot;</span>);
                                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
                        }
                }
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a51f3b3a2fe684b082ef2d5190a125df7"></a><!-- doxytag: member="ramscanner_collect.c::lookup_smaps" ref="a51f3b3a2fe684b082ef2d5190a125df7" args="(pid_t PID, sizestats *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lookup_smaps </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsizestats.html">sizestats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function to open the /proc/PID/smaps file, then call <a class="el" href="ramscanner__collect_8c.html#acdce25f682f7cc424909fbabf5f005db">parse_smaps_file()</a> to read the smaps file and store the results. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00113">113</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8c_source.html#l00039">cleanup_and_exit()</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00034">parse_smaps_file()</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00032">PROC_PATH</a>, and <a class="el" href="ramscanner__literals_8h_source.html#l00036">SMAPS_FILENAME</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00518">inspect_processes()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">char</span> buffer[BUFSIZ];
        FILE *file;
        <span class="keywordtype">int</span> ret;
        sprintf(buffer, <span class="stringliteral">&quot;%s/%d/%s&quot;</span>, <a class="code" href="ramscanner__literals_8h.html#a149096b34cfc7cb6a5fefebcd953f4d5">PROC_PATH</a>, PID, <a class="code" href="ramscanner__literals_8h.html#a9962641fd63f927cdd74599ec3043490">SMAPS_FILENAME</a>);
        errno = 0;
        file = fopen(buffer, <span class="stringliteral">&quot;r&quot;</span>);
        <span class="keywordflow">if</span> (file == NULL) {
                perror(<span class="stringliteral">&quot;Error opening smaps file&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }
        <a class="code" href="ramscanner__collect_8c.html#acdce25f682f7cc424909fbabf5f005db">parse_smaps_file</a>(file, stats);
        errno = 0;
        ret = fclose(file);
        <span class="keywordflow">if</span> (ret != 0) {
                perror(<span class="stringliteral">&quot;Error closing smaps file&quot;</span>);
                errno = 0;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a712555ae6bff502a411333314d8b2b95"></a><!-- doxytag: member="ramscanner_collect.c::make_another_vmst_in_opt" ref="a712555ae6bff502a411333314d8b2b95" args="(options *opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structvmastats.html">vmastats</a>* make_another_vmst_in_opt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoptions.html">options</a> *&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>opt stores an array of vmastats structs so that they persist, can be access, and cleaned up at the end of the program. This makes another vmastats available and returns a pointer to it. The vmastats pointer will not persist, as realloc does not guarantee memory stays in the same place, so persistent access to this struct requires storing an index, which is most easily accessed for the newest vmastats struct by getting (opt-&gt;vmacount - 1). </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00406">406</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8c_source.html#l00039">cleanup_and_exit()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00104">options::vmacount</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00101">options::vmas</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00432">lookup_maps_with_PID()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="structvmastats.html">vmastats</a> *temp;
        <a class="code" href="structvmastats.html">vmastats</a> *newelement;
        errno = 0;
        temp = realloc(opt-&gt;<a class="code" href="structoptions.html#a694f66a9718a83a7948aeba212945e4f">vmas</a>, <span class="keyword">sizeof</span>(*temp) * (opt-&gt;<a class="code" href="structoptions.html#a70a839c12fbd2059a75cda3b8af76085">vmacount</a> + 1));
        <span class="keywordflow">if</span> (temp == NULL) {
                perror(<span class="stringliteral">&quot;Error allocating new vmastats&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }
        opt-&gt;<a class="code" href="structoptions.html#a694f66a9718a83a7948aeba212945e4f">vmas</a> = temp;
        (opt-&gt;<a class="code" href="structoptions.html#a70a839c12fbd2059a75cda3b8af76085">vmacount</a>)++;
        newelement = &amp;(temp[opt-&gt;<a class="code" href="structoptions.html#a70a839c12fbd2059a75cda3b8af76085">vmacount</a> - 1]);
        memset(newelement, 0, <span class="keyword">sizeof</span>(*newelement));
        <span class="keywordflow">return</span> newelement;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa002283ea1ba949cdd204719353732e1"></a><!-- doxytag: member="ramscanner_collect.c::parse_bitfield" ref="aa002283ea1ba949cdd204719353732e1" args="(uint64_t bitfield, options *opt, FILE *filepageflags, FILE *filepagecount, pagedetaildata *currentdpage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void parse_bitfield </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bitfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoptions.html">options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepageflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepagecount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpagedetaildata.html">pagedetaildata</a> *&#160;</td>
          <td class="paramname"><em>currentdpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is passed the 64-bit bitfield retrieved from the process' pagemap, and parses this information. If the process is not swapped then it has a PFN, which it will pass to the function <a class="el" href="ramscanner__collect_8c.html#ab0fccb96a9d60f7da5326e4616541227">use_pfn()</a> to extract information from /proc/kpagemaps and /proc/kpagecount. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00254">254</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8h_source.html#l00076">options::detail</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00018">PAGEPRESENT</a>, <a class="el" href="ramscanner__common_8h_source.html#l00138">pagedetaildata::pageshift</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00017">PAGESHIFT</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00022">PAGESHIFTBITS</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00019">PAGESWAPPED</a>, <a class="el" href="ramscanner__common_8h_source.html#l00144">pagedetaildata::pfn</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00020">PFNBITS</a>, <a class="el" href="ramscanner__common_8h_source.html#l00135">pagedetaildata::present</a>, <a class="el" href="ramscanner__common_8h_source.html#l00141">pagedetaildata::swap</a>, and <a class="el" href="ramscanner__collect_8c_source.html#l00164">use_pfn()</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00325">lookup_pagemap_with_addresses()</a>.</p>
<div class="fragment"><pre class="fragment">{
        uint64_t pfnbits;

        <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a>) {
                uint64_t pageshift;

                <span class="keywordflow">if</span> (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#a6fcc63835d2bc675ea31454fa7e0c8e8">PAGEPRESENT</a>) 
                        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a036707143fb5b570d5a652f406140c0f">present</a> = 1;
                <span class="keywordflow">else</span>
                        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a036707143fb5b570d5a652f406140c0f">present</a> = 0;
                pageshift = bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#a5eebce4227cef68c34e40c9a47156f93">PAGESHIFTBITS</a>;
                pageshift = pageshift &gt;&gt; <a class="code" href="ramscanner__collect_8h.html#aaab0f5ef194d7ed0467560bcdc110588">PAGESHIFT</a>;
                currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a22b602c3181c247f9763370ecffd707c">pageshift</a> = pageshift;
        }
        <span class="keywordflow">if</span> (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#a025d5ecf9a3bf5dba6829eed58cd667a">PAGESWAPPED</a>) {
                <span class="comment">/* Omitting swap type and swap offset information. */</span>
                <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a>)
                        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#abf014a39240094609ea641ae130ca2f3">swap</a> = 1;
                <span class="keywordflow">return</span>;
        }
        <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a>)
                currentdpage-&gt;<a class="code" href="structpagedetaildata.html#abf014a39240094609ea641ae130ca2f3">swap</a> = 0;
        pfnbits = bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#ad684cec3813f71ea66ce981dd058f08f">PFNBITS</a>;

        <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a>)
                currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a4ec963e2c6312e3a4573aa3f38c18341">pfn</a> = pfnbits;

        <a class="code" href="ramscanner__collect_8c.html#ab0fccb96a9d60f7da5326e4616541227">use_pfn</a>(pfnbits, opt, filepageflags, filepagecount, currentdpage);
}
</pre></div>
</div>
</div>
<a class="anchor" id="acdce25f682f7cc424909fbabf5f005db"></a><!-- doxytag: member="ramscanner_collect.c::parse_smaps_file" ref="acdce25f682f7cc424909fbabf5f005db" args="(FILE *file, sizestats *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void parse_smaps_file </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsizestats.html">sizestats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts data from the process' smaps file (see "man proc" for details on smaps) and stores it in the sizestats struct. It is dependent on the format of the output of smaps remaining as: [Address]-[Address] for the first line of an entry, and Label: [size] kB for each size stat.</p>
<p>For example: b77f3000-b77f4000 r--p 002a1000 08:01 15343049 /usr/lib/locale/locale-archive Size: 4 kB Rss: 4 kB Pss: 0 kB Shared_Clean: 4 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 0 kB Referenced: 4 kB Anonymous: 0 kB Swap: 0 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Locked: 0 kB</p>
<p>It will extract Size, Rss, Pss, Referenced, Anonymous, Swap and Locked for each entry. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00034">34</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8h_source.html#l00048">sizestats::anon</a>, <a class="el" href="ramscanner__common_8h_source.html#l00051">sizestats::locked</a>, <a class="el" href="ramscanner__common_8h_source.html#l00024">sizestats::pss</a>, <a class="el" href="ramscanner__common_8h_source.html#l00041">sizestats::refd</a>, <a class="el" href="ramscanner__common_8h_source.html#l00021">sizestats::rss</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00010">SMAPS_ANON</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00012">SMAPS_LOCKED</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00008">SMAPS_PSS</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00009">SMAPS_REFD</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00007">SMAPS_RSS</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00011">SMAPS_SWAP</a>, <a class="el" href="ramscanner__literals_8h_source.html#l00006">SMAPS_VSS</a>, <a class="el" href="ramscanner__common_8h_source.html#l00045">sizestats::swap</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00018">sizestats::vss</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00113">lookup_smaps()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">char</span> buffer[BUFSIZ];
        <span class="keywordtype">char</span> *pt = buffer;
        <span class="keywordtype">char</span> *pos = NULL;
        <span class="keywordtype">size_t</span> n = 0;
        uint32_t temp;
        uint32_t arg1;
        uint32_t arg2;
        <span class="keywordflow">while</span> (getline(&amp;pt, &amp;n, file) &gt; 0) {
                <span class="keywordflow">if</span> (sscanf(pt, <span class="stringliteral">&quot;%x-%x&quot;</span>, &amp;arg1, &amp;arg2) == 2) {
                        <span class="comment">/* First line of a vma detected, do nothing. */</span>
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(pt, <a class="code" href="ramscanner__literals_8h.html#a8b194f7ae0da739da8b347978eb39e8b">SMAPS_VSS</a>) != NULL) {
                        pos = strchr(pt, <span class="charliteral">&#39;:&#39;</span>);
                        sscanf(pos + 1, <span class="stringliteral">&quot;%d kB&quot;</span>, &amp;temp);
                        stats-&gt;<a class="code" href="structsizestats.html#a989f65215df751197aecf56514113e17">vss</a> += temp;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(pt, <a class="code" href="ramscanner__literals_8h.html#a6b97c95be256ab1b46c18d6eea610888">SMAPS_RSS</a>) != NULL) {
                        pos = strchr(pt, <span class="charliteral">&#39;:&#39;</span>);
                        sscanf(pos + 1, <span class="stringliteral">&quot;%d kB&quot;</span>, &amp;temp);
                        stats-&gt;<a class="code" href="structsizestats.html#a25e117298413f3466bf12fd26a120029">rss</a> += temp;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(pt, <a class="code" href="ramscanner__literals_8h.html#a45219167350ee090f722a60328b89677">SMAPS_PSS</a>) != NULL) {
                        pos = strchr(pt, <span class="charliteral">&#39;:&#39;</span>);
                        sscanf(pos + 1, <span class="stringliteral">&quot;%d kB&quot;</span>, &amp;temp);
                        stats-&gt;<a class="code" href="structsizestats.html#aec1ab10d6afc1baa8e469cfb5ef28776">pss</a> += temp;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(pt, <a class="code" href="ramscanner__literals_8h.html#a283cc9359327796df5277c781a9a8c45">SMAPS_REFD</a>) != NULL) {
                        pos = strchr(pt, <span class="charliteral">&#39;:&#39;</span>);
                        sscanf(pos + 1, <span class="stringliteral">&quot;%d kB&quot;</span>, &amp;temp);
                        stats-&gt;<a class="code" href="structsizestats.html#a6069a72ada665f41a0d77ad96e50be0f">refd</a> += temp;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(pt, <a class="code" href="ramscanner__literals_8h.html#a4d9fdcb45dd6e9221f0003f6862c9471">SMAPS_ANON</a>) != NULL) {
                        pos = strchr(pt, <span class="charliteral">&#39;:&#39;</span>);
                        sscanf(pos + 1, <span class="stringliteral">&quot;%d kB&quot;</span>, &amp;temp);
                        stats-&gt;<a class="code" href="structsizestats.html#a512e0892c179f51bc0670a4f91434ab0">anon</a> += temp;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(pt, <a class="code" href="ramscanner__literals_8h.html#a2d9cc1db38cbd5f19c3a93df1e426332">SMAPS_SWAP</a>) != NULL) {
                        pos = strchr(pt, <span class="charliteral">&#39;:&#39;</span>);
                        sscanf(pos + 1, <span class="stringliteral">&quot;%d kB&quot;</span>, &amp;temp);
                        stats-&gt;<a class="code" href="structsizestats.html#a9b819f31c8c13244c6260492ba374948">swap</a> += temp;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(pt, <a class="code" href="ramscanner__literals_8h.html#a648475afb529ee27ba8d8e6e8aa8b7db">SMAPS_LOCKED</a>) != NULL) {
                        pos = strchr(pt, <span class="charliteral">&#39;:&#39;</span>);
                        sscanf(pos + 1, <span class="stringliteral">&quot;%d kB&quot;</span>, &amp;temp);
                        stats-&gt;<a class="code" href="structsizestats.html#adebb5c2d09af509dc6196a96c8958646">locked</a> += temp;
                }
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="afce862818e4b085e82ab08a9e3d75cfd"></a><!-- doxytag: member="ramscanner_collect.c::store_flags_in_page" ref="afce862818e4b085e82ab08a9e3d75cfd" args="(uint64_t bitfield, pagedetaildata *currentdpage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void store_flags_in_page </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bitfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpagedetaildata.html">pagedetaildata</a> *&#160;</td>
          <td class="paramname"><em>currentdpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function to inspect the page flags extracted and store the results in the page detail data struct. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00139">139</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8h_source.html#l00157">pagedetaildata::anonymous</a>, <a class="el" href="ramscanner__common_8h_source.html#l00154">pagedetaildata::dirty</a>, <a class="el" href="ramscanner__common_8h_source.html#l00162">pagedetaildata::ksm</a>, <a class="el" href="ramscanner__common_8h_source.html#l00150">pagedetaildata::locked</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00039">PAGEFLAG_ANON</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00038">PAGEFLAG_DIRTY</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00042">PAGEFLAG_KSM</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00036">PAGEFLAG_LOCKED</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00037">PAGEFLAG_REFERENCED</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00041">PAGEFLAG_SWAPBACKED</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00040">PAGEFLAG_SWAPCACHE</a>, <a class="el" href="ramscanner__common_8h_source.html#l00151">pagedetaildata::referenced</a>, <a class="el" href="ramscanner__common_8h_source.html#l00161">pagedetaildata::swapbacked</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00158">pagedetaildata::swapcache</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00164">use_pfn()</a>.</p>
<div class="fragment"><pre class="fragment">{
        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#ab79ca79b587b4646615ae409c636aa90">locked</a>     = (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#a07cd878b96366299daba95a08c470ffd">PAGEFLAG_LOCKED</a>)     ? 1 : 0;
        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a1aedae3537012074ad0e3ab7d093271e">referenced</a> = (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#a27318e549092ffbdeb35cb67a0aaad08">PAGEFLAG_REFERENCED</a>) ? 1 : 0;
        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a194a712df4b4857b536603185f1630d2">dirty</a>      = (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#af0631f3ea8e405961f1252399f4c7ad7">PAGEFLAG_DIRTY</a>)      ? 1 : 0;
        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a42cda287fd0972398739701653dde809">anonymous</a>  = (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#aacf9160b38efd8c5c2b6017982c8213a">PAGEFLAG_ANON</a>)       ? 1 : 0;
        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#aa066a464cadc63d63d64cc9372ea1658">swapcache</a>  = (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#afd5ead34440ee1d2ae740356896f43b4">PAGEFLAG_SWAPCACHE</a>)  ? 1 : 0;
        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a3fe2eefda8955b201eaf9ddf9077243f">swapbacked</a> = (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#a471912274d4f2f4774e3ef459390aed3">PAGEFLAG_SWAPBACKED</a>) ? 1 : 0;
        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a94233c04763e267acacd5116a443b2d6">ksm</a>        = (bitfield &amp; <a class="code" href="ramscanner__collect_8h.html#a0e66f18af6aebc6b2a13248c6a9cd28e">PAGEFLAG_KSM</a>)        ? 1 : 0;

}
</pre></div>
</div>
</div>
<a class="anchor" id="ab0fccb96a9d60f7da5326e4616541227"></a><!-- doxytag: member="ramscanner_collect.c::use_pfn" ref="ab0fccb96a9d60f7da5326e4616541227" args="(uint64_t pfn, options *opt, FILE *filepageflags, FILE *filepagecount, pagedetaildata *currentdpage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void use_pfn </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoptions.html">options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepageflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filepagecount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpagedetaildata.html">pagedetaildata</a> *&#160;</td>
          <td class="paramname"><em>currentdpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the hash table of pages to see if this page has been mapped before. This is done so that it is possible to compare the number of times the page reports it has been mapped to the number of times the primary or secondary processes map it. Looks up the number of times the page reports it has been mapped in /proc/kpagecount. If it has only been mapped once then the page's size will be added to the Unique Set Size (Uss). If the program has been told to look for details, it will look up /proc/kpageflags and retrieve a 64-bit bitfield of the flags set on that process, and pass it to the function <a class="el" href="ramscanner__collect_8c.html#afce862818e4b085e82ab08a9e3d75cfd">store_flags_in_page()</a>. </p>

<p>Definition at line <a class="el" href="ramscanner__collect_8c_source.html#l00164">164</a> of file <a class="el" href="ramscanner__collect_8c_source.html">ramscanner_collect.c</a>.</p>

<p>References <a class="el" href="ramscanner__common_8c_source.html#l00039">cleanup_and_exit()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00079">options::compactdetail</a>, <a class="el" href="ramscanner__common_8h_source.html#l00076">options::detail</a>, <a class="el" href="ramscanner__collect_8h_source.html#l00044">KBSIZE</a>, <a class="el" href="ramscanner__common_8h_source.html#l00113">pagesummarydata::memmapped</a>, <a class="el" href="ramscanner__common_8c_source.html#l00016">newkey()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00117">pagesummarydata::procmapped</a>, <a class="el" href="ramscanner__collect_8c_source.html#l00139">store_flags_in_page()</a>, <a class="el" href="ramscanner__common_8h_source.html#l00073">options::summary</a>, <a class="el" href="ramscanner__common_8h_source.html#l00090">options::summarypages</a>, <a class="el" href="ramscanner__common_8h_source.html#l00098">options::summarystats</a>, <a class="el" href="ramscanner__common_8h_source.html#l00147">pagedetaildata::timesmapped</a>, and <a class="el" href="ramscanner__common_8h_source.html#l00030">sizestats::uss</a>.</p>

<p>Referenced by <a class="el" href="ramscanner__collect_8c_source.html#l00254">parse_bitfield()</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">int</span> ret;
        uint64_t bitfield;

        <span class="keywordtype">size_t</span> elementsize = <span class="keyword">sizeof</span>(uint64_t);
        uint64_t index = pfn * elementsize;

        <a class="code" href="structpagesummarydata.html">pagesummarydata</a> *pData = NULL;
        pData = g_hash_table_lookup(opt-&gt;<a class="code" href="structoptions.html#a3f12bfa404a3402c0506d8dc52da4c4c">summarypages</a>, &amp;pfn);

        <span class="keywordflow">if</span> (pData == NULL) {

        <span class="comment">/*</span>
<span class="comment">         * If the page is found in the about g_hash_table_lookup(), then it will</span>
<span class="comment">         * always increment the number of times the page has been mapped by a</span>
<span class="comment">         * process. If no page is found, then it checks to see if opt-&gt;summary,</span>
<span class="comment">         * opt-&gt;detail or opt-&gt;compactdetail exist. If this is not the case,</span>
<span class="comment">         * then it is checking if it is being mapped by a secondary process. If</span>
<span class="comment">         * it is a secondary process, then no extra pages will be added to</span>
<span class="comment">         * opt-&gt;summarypages.</span>
<span class="comment">         */</span>

                <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#aa46b832c2b73ca872baee120bb4bc755">summary</a> || opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a> || opt-&gt;<a class="code" href="structoptions.html#aef87d29ef02ab135ff237eb2c7b9f9a7">compactdetail</a>) {
                        errno = 0;
                        pData = malloc(<span class="keyword">sizeof</span>(*pData));
                        <span class="keywordflow">if</span> (pData == NULL) {
                                perror(<span class="stringliteral">&quot;Error allocating page summary data&quot;</span>);
                                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
                        }
                        pData-&gt;<a class="code" href="structpagesummarydata.html#a5d3c0039dc383c052e40193e791bf591">procmapped</a> = 1;
                        pData-&gt;<a class="code" href="structpagesummarydata.html#a1a2f3d1078136de046abbde0c345f797">memmapped</a> = 0; <span class="comment">/*Indicates a newly-mapped page*/</span>
                        g_hash_table_insert(opt-&gt;<a class="code" href="structoptions.html#a3f12bfa404a3402c0506d8dc52da4c4c">summarypages</a>, <a class="code" href="ramscanner__common_8c.html#af9b4ea763f4ee48879a5efc735d079c5">newkey</a>(pfn), 
                                            pData);
                }
        } <span class="keywordflow">else</span> {
                pData-&gt;<a class="code" href="structpagesummarydata.html#a5d3c0039dc383c052e40193e791bf591">procmapped</a> += 1;
        }

        <span class="keywordflow">if</span> (!(opt-&gt;<a class="code" href="structoptions.html#aa46b832c2b73ca872baee120bb4bc755">summary</a> || opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a> || opt-&gt;<a class="code" href="structoptions.html#aef87d29ef02ab135ff237eb2c7b9f9a7">compactdetail</a>))
                <span class="keywordflow">return</span>;

        errno = 0;
        ret = fseek(filepagecount, index, SEEK_SET);
        <span class="keywordflow">if</span> (ret == -1) {
                perror(<span class="stringliteral">&quot;Error seeking in kpagecount&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }

        errno = 0;
        ret = fread(&amp;bitfield, <span class="keyword">sizeof</span>(bitfield), 1, filepagecount);
        <span class="keywordflow">if</span> (ret != 1) {
                perror(<span class="stringliteral">&quot;Error reading kpagecount&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }

        <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="structoptions.html#aa46b832c2b73ca872baee120bb4bc755">summary</a> &amp;&amp; (pData-&gt;<a class="code" href="structpagesummarydata.html#a1a2f3d1078136de046abbde0c345f797">memmapped</a> == 0)) {
                <span class="comment">/* This block of code is called only on a newly-mapped page. */</span>
                pData-&gt;<a class="code" href="structpagesummarydata.html#a1a2f3d1078136de046abbde0c345f797">memmapped</a> = bitfield;
                <span class="keywordflow">if</span> (bitfield == 1)
                        opt-&gt;<a class="code" href="structoptions.html#a40fbf684316fd9e0819ab090506d3c19">summarystats</a>.<a class="code" href="structsizestats.html#a8aad02e33d374e9e238f204f8f7abc08">uss</a> += getpagesize()/<a class="code" href="ramscanner__collect_8h.html#aa44bab413ffdffd5924758b448641ea3">KBSIZE</a>;
        }

        <span class="keywordflow">if</span> (!(opt-&gt;<a class="code" href="structoptions.html#a57b3831a986f49e50f1746551d7c312e">detail</a> || opt-&gt;<a class="code" href="structoptions.html#aef87d29ef02ab135ff237eb2c7b9f9a7">compactdetail</a>))
                <span class="keywordflow">return</span>;

        currentdpage-&gt;<a class="code" href="structpagedetaildata.html#a2301773722c04effa8e6a282a5a7242b">timesmapped</a> = bitfield;
        errno = 0;
        ret = fseek(filepageflags, index, SEEK_SET);
        <span class="keywordflow">if</span> (ret == -1) {
                perror(<span class="stringliteral">&quot;Error seeking in kpageflags&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }
        errno = 0;
        ret = fread(&amp;bitfield, <span class="keyword">sizeof</span>(bitfield), 1, filepageflags);
        <span class="keywordflow">if</span> (ret != 1) {
                perror(<span class="stringliteral">&quot;Error reading kpageflags&quot;</span>);
                <a class="code" href="ramscanner__common_8c.html#a9a3df3681470f93c9cbf201fb3e62795">cleanup_and_exit</a>(EXIT_FAILURE);
        }
        <a class="code" href="ramscanner__collect_8c.html#afce862818e4b085e82ab08a9e3d75cfd">store_flags_in_page</a>(bitfield, currentdpage);
}
</pre></div>
</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Mar 1 2012 13:27:38 for Ramscanner by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
